#+TODO: SLIDES RECORD EDIT REVIEW | DONE
#+STARTUP: overview
* Notes
** Helpful Claude videos
- https://www.youtube.com/watch?v=Ffh9OeJ7yxw
** Using claude-code
I find that it is better to discuss a change in plan mode before asking AI to execute it.

/resume is very useful, even after /clear!

Keep design decisions in file so they aren't lost by compact or clear.

*** Prompts for my lectures

I am teaching the third introduction to programming course in the Auburn Computer Science program.  This course focuses on Software Construction and uses python 3.14 with PySide6 to produce desktop GUI applications.  So far the students have seen:
- QWidget
- Various simple widget types (QPushButton, QCheckBox etc)
- Various layouts
- Signals and slots
- Widget and layout sizing
- QMainWindow and associated widgets

I follow a naming convention for functions/methods acting as slots.  Unless an ambiguity is  created, a signal named X on a widget name Y will be named Y_X.  For example, popup_dialog = QMessageBox(...) has a signal named finished.  I would create a slot named popup_dialog_finished() to respond to that signal.
  
** Best practices from: https://www.youtube.com/watch?v=gv0WHhKelSE
- Use CLAUDE.md -- create in strategic locations to document commands, style guidelines, and key context
  At least in project root, maybe in user home.  Can also place in subdirectories but it can get overwhelming to Claude.  Note that you can use @ to tell claude to reference another file from within CLAUDE.md (@CODING_STANDARDS.md, for example).
- Permissions management -- Curate allowed tools to reduce interruptions
- Integration setup -- Install tools like gh CLI (rather than an MCP) for seamless GitHub workflows and let Claude handle version control
- Context management:
  - /clear
  - /compact
- "Think hard"
** Effective workflows (same video)
- Planning todo's -- get Claude to plan and create todo list
- Smart vibe coding -- leverage TDD and regular commits to vibe code with guardrails.
- Use screenshots to compare implementations against mockups and provide guidance to Claude on design
** Advanced techniques
- Use multiple Claude in parallel
- Use escape!
- Tool expansion and MCP -- integrate bash tools, MCP servers and custom slash commands.
- Headless automation -- use -p mode for CI/CD pipelines and large-scale changes
** ChatGPT Codex

https://developers.openai.com/codex/cli

** VSC AI stuff

Nice tips here: https://www.youtube.com/watch?v=dutyOc_cAEU

https://www.youtube.com/@code/videos

** Stylesheets
Demo how to modify style but then show qdarkstyle
* Links
** M1
- gitignore repo: https://github.com/github/gitignore/blob/main/Python.gitignore
- git rebase: https://www.atlassian.com/git/tutorials/merging-vs-rebasing
- .gitignore wildcards and other .gitignore info
- github flow/gitflow
- 
** M2
- uv installation: https://docs.astral.sh/uv/
- Qt
  - PySide
  - Qt
- reStructured text spec: https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html
- reStructured text quickstart: https://docutils.sourceforge.io/docs/user/rst/quickstart.html
- Types
  - Full specification: https://typing.python.org/en/latest/spec/index.html
  - mypy typing cheatsheet: https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html
  - Python typing docs: https://docs.python.org/3/library/typing.html
** M3
- binary numbers and bit-wise operations in Python
* Python corners
- [X] Type annotations 1 -- 4970-M6
- [X] Data classes
- [ ] Typing annotations 2 -- probably needed
  - type co/contr-variance
  - Protocols
- [ ] Properties and encapsulation
- [ ] Decorators 1 -- 4970-M5
- [ ] Decorators 2 -- 4970-M5
- [ ] String encodings -- 4970-M5
- [ ] Lambdas -- 4970-M5
- [ ] List comprehensions -- 4970-M2 -- note this is covered in 1200/1210
- [ ] Iterators -- 4970-M4
- [ ] Generators 1 -- 4970-M4
- [ ] Generators 2 -- 4970-M4
- [ ] Enums -- 4970-M3
- [ ] Unit testing -- note this is covered in 1210 -- 4970-M2
- [ ] TDD -- 4970-M3
* Important!!!
- M2: I might wan to move type annotations out of module 2 since I don't use them in module 3.  Could put something else there in its place.  What comes up in module 3?
* REVIEW Module 1 [0/8] (3:03) [REVIEW:8] 
** REVIEW Introduction (0:16)
** REVIEW Installing Git (0:26)
** REVIEW Introduction to Git (0:18)
** REVIEW Tagging and branching in Git (0:42)
** REVIEW Undoing changes (0:13)
** REVIEW Git remote repositories 1 (0:26)
** REVIEW Git remote repositories 2 (0:17)
** REVIEW Finishing up (0:25)
* REVIEW Module 2: Careful review!!! make sure no bleed-through! [1/10] (3:52) [REVIEW:9 DONE:1]
** REVIEW Initial Tool Setup (0:18)
** REVIEW VSC setup (0:26)
** REVIEW Introduction to PySide (0:15)
** REVIEW Widget basics (0:22)
** REVIEW Layouts (0:27)
** REVIEW Signals and slots (0:15)
** REVIEW First application (0:35)
** REVIEW Cleaning up (0:28)
** REVIEW Creating reusable components (0:22)
** DONE AI: Styling our application (0:24)
CLOSED: [2025-12-11 Thu 20:04]
* EDIT Module 3 [0/9] [SLIDES:1 EDIT:4 REVIEW:4]
** REVIEW Widget sizing (0:41)
** REVIEW Window widgets (0:18)
** REVIEW Standard dialogs (0:27)
** EDIT Collection widgets
** EDIT Python corner: Type annotations 1
** EDIT Python corner: Data classes
** REVIEW Application (0:27)
** EDIT AI: Adding a database
* SLIDES Module 4 [0/15] [SLIDES:11 RECORD:1 EDIT:3]
** EDIT Custom dialogs
Calculator dialog in steps:
1) Start with main app with no dialog (and no button to open the dialog)!  This is the starting point.
2) Add the button but show message box
3) Add dialog but with no callbacks, include a method to get the displayed value and use it in the modal example -- user must manually close dialog...what if they didn't want to use the value they calculated
4) Add buttons to the dialog and use existing signals.  Is this far enough to demo most of what's in the slides?
5) modify original calculator to emit signal on = (then use it to accept dialog and thereby populate text field) -- maybe in future lecture.
** EDIT Non-modal dialogs
Show non-modal calculator example then show some window flags?
** EDIT Input validation
Demo ideas:
1) contacts(-ai) project, add mask to phone number input.  Note that his breaks existing data.  Demo this, then show how to fix sample data and delete db.
2) contacts add validator to email input?
3) change calculator to permit user input?
** SLIDES Long-running background tasks
https://www.pythonguis.com/tutorials/multithreading-pyside6-applications-qthreadpool/
** SLIDES Qt's resource system: translations and images
  https://www.pythonguis.com/tutorials/packaging-data-files-pyside6-with-qresource-system/
** SLIDES Icon themes
See QIcon docs and perhaps something on Qt web site
https://medium.com/@yakupcengiz/exploring-qt-icon-themes-and-customization-8debfadf1580
https://www.pythonguis.com/faq/built-in-qicons-pyqt/
Fix calculator button in dialog demo:
#+BEGIN_SRC python
   calc_button = QToolButton()
   calc_button.setIcon(QIcon.fromTheme("accessories-calculator"))
   calc_button.setAutoRaise(True)
   calc_button.setToolTip("Open Calculator")
   calc_button.clicked.connect(self._open_calculator)  
#+END_SRC
** SLIDES Style sheets?
  - https://doc.qt.io/qt-6/stylesheet.html -- has a big "example" section!
  - perhaps focus on qdarkstyle and similar projects
** SLIDES AI: Plan mode
** Designing reusable components (part 2): cohesion
Make table version of app from last module.

Pull the editor out as its own control.  No buttons?
- with buttons: we'd have to subclass to use in dialog
- without buttons: in-line and dialog versions would each need their own buttons, these buttons would not sync with 
** Designing reusable components (part 3): coupling
- using events to decouple
- using an ABC to avoid direct connection to editor?
** SLIDES AI: Agents
https://www.youtube.com/watch?v=6MLyc3jYisQ -- this goes through a great "toy" example.  I could also build a toy.

Idea: create agent for commenting.  Provide examples in the agent description.  This could be very nice.  Could integration with git commit process.

https://www.pubnub.com/blog/best-practices-for-claude-code-sub-agents/ -- read!

Article above had useful text:

#+BEGIN_QUOTE
Claude Code subagents are specialized, autonomous assistants designed to execute specific, well-defined tasks within a larger workflow. Unlike a general-purpose agent that handles a wide range of requests, a subagent operates with its own distinct system prompt, a curated set of tool permissions, and an isolated context window. This modular design allows you to create a team of AI experts. Give them roles: Product Spec, Architect, Implementer/Tester, and chain them with Claude Code hooks to create a dependable software pipeline:
#+END_QUOTE

Anthropic's site also has list of benefits of agents.

Recommendations:
- Subagents for /tasks/ not roles!  Don't define a UX subagent.  Give subagent's specific tasks.



Demo: Set up a agents for appearance, uv, web scraping?

** SLIDES AI MCP
https://github.com/jparkerweb/mcp-sqlite or "superbase" (seen recommendations online, might be safer?)
** SLIDES Python corner: Abstract base classes and Protocols
** SLIDES Python corner: Properties and encapsulation
** SLIDES Application
  Perhaps here I'll go into more detail about typical application structure

* SLIDES Module 5 [0/4] [SLIDES:4]
** Maybe theme of this module is software design?
** SLIDES Graphics?
https://doc.qt.io/qtforpython-6/overviews/qtwidgets-graphicsview.html#graphics-view-framework
** SLIDES Translation of string constants for internationalization and other i8n stuff (utf-8 text etc)?
** SLIDES Show widget.setWindowIcon() among other tips
** RECORD Qt designer
- On macos to run designer use: ~open .venv/lib/python3.14/site-packages/PySide6/Designer.app~
- On windows they can probably just =uv run pyside6-designer=
- After playing around a bit I can see that putting widgets on form, selecting them and then choosing layout from context menu is better than manually trying to add them to existing layout.
- General help: https://doc.qt.io/qt-6/qtdesigner-index.html
- using .ui files from python: https://doc.qt.io/qt-6/designer-using-a-ui-file-python.html
* SLIDES Module 6 [0/1] [SLIDES:1]
** SLIDES User interface testing
  Create a series of videos which show how to do UI testing.

  1) trivial case: UI robot presses buttons etc
  2) more realistic: 2 layers, one uses UI robot and verifies interactions with a UI model, the other just tests a UI model.  Need to develop a few examples like this.
* SLIDES Module 7 [0/1] [SLIDES:1]
** SLIDES Packaging apps for distribution
  - consider: https://doc.qt.io/qtforpython-6/deployment/deployment-pyside6-deploy.html#pyside6-deploy.  It doesn't use uv but maybe its a good way to go?
  - https://packaging.python.org/en/latest/overview/
  - https://packaging.python.org/en/latest/guides/distributing-packages-using-setuptools/ -- outdated?  how?
  - perhaps start by reading through https://packaging.python.org/en/latest/guides/
  - modernization of setuptools: https://setuptools.pypa.io/en/latest/build_meta.html    (PEP517 modernizes with pyproject.toml)
  - but...we're not using setuptools to build.  We'll use uv.  Any docs?
;; Local Variables:
;; eval: (load-library "lecture-management.el")
;; eval: (add-hook 'org-after-todo-state-change-hook 'lecture-auto-update-summary)
;; End:
